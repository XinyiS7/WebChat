import osimport requestsfrom dotenv import load_dotenv# 1. 获取 API 密钥load_dotenv()api_key = os.getenv("DEEPSEEK_API_KEY")if not api_key:    print("⚠️ 错误：找不到环境变量 DEEPSEEK_API_KEY！请先设置它。")    exit(1)# 2. 可调用函数def query_deepseek_api_model(text, api_key, mode):    """    与DeepSeek API交互的函数    :param mode:    :param text: 要发送的文本    :param api_key: API密钥    :return: API响应内容    """    headers = {        "Authorization": f"Bearer {api_key}",        "Content-Type": "application/json"    }    # 这是新增了切换之后，对字典payload中"model"的新的赋值方式    model_type = "deepseek-reasoner" if mode == 'coder' else "deepseek-chat"    temper = 0.7 if mode == 'coder' else 1.2    print(f"[DEBUG] 输入模式: {mode} → 模型类型: {model_type}")  # 确认输入    payload = {        "model": model_type,  # 指定模型        "messages": [            {                "role": "user",                "content": text            }        ],        "temperature": temper,        "max_tokens": 2000    }    # print(f"[DEBUG] 请求载荷: {payload}")  # 打印完整 payload    try:        response = requests.post(            "https://api.deepseek.com/v1/chat/completions",  # 使用v1端点            headers=headers,            json=payload        )        print(f"[DEBUG] API 响应状态码: {response.status_code}")        # print(f"[DEBUG] API 响应内容: {response.text}")  # 关键检查点！        # 检查响应状态        if response.status_code == 200:            return response.json()["choices"][0]["message"]["content"]        else:            # 打印详细的错误信息            error_detail = response.json().get("error", {}).get("message", "未知错误")            raise Exception(f"API请求失败: {response.status_code} - {error_detail}")    except Exception as e:        raise Exception(f"API请求异常: {str(e)}")if __name__ == "__main__":    load_dotenv()    api_key = os.getenv("DEEPSEEK_API_KEY")    if not api_key:        print("⚠️ 错误：找不到环境变量 DEEPSEEK_API_KEY！请先设置它。")        exit(1)    print(f"你的api_key的后四位是：: {api_key[-4:]}")